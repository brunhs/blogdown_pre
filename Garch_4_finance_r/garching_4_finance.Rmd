---
title: "Garching our way out"
subtitle: 'Univariate time series analysis with our beloved R'
slug: univariate-sherlock-series-analysis
author: "Bruno Schock"
date: "2020-01-12"
categories: []
tags: 
  - prediction
  - R
  - time series
output:
  html_document:
    toc: yes
    number_sections: yes
    theme: cosmo
    highlight: tango
---




# **Volatility, "Xeroque" and the unnecessary complexity**

## **Simple matter**
 
Hello everyone, it's your boy Brun here, like always i've been doing many courses around, many things going on now that I moved to a new city, with a new job, new perspectives, life is being pretty volatile, you know? Do you know something that's pretty volatile too? Stocks! Yeah boy, they move pretty fast and with a very non-gentile pattern, but fortunately the world gave us some time series analysis and here we are.

Of course we are going to work with some price returns, do you know something better than returns? They're pretty good talking about the recent past, they can help us being more rich (time is money works here?), well, since we already talked about some time series in previous posts, in a small piece of how to predict with some different models, we're going to talk about some volatility estimation, something that can concern us, right? Trying to imagine if some time series is going to behave more volatile in the next future is something pretty good for us, since we can protect ourselves of these movements, no more chatting, let's begin. 
 

```{r, include=TRUE, message=FALSE, warning=FALSE}
#Loading our packages
library(PerformanceAnalytics)




```



## **Get the data, 'bo1s' and 'g4ls'**

Yeah, this chunk is to get the data and plot it, you know we can't keep without it!


```{r, include=TRUE, message=FALSE, warning=FALSE}
#Loading our stocks
#install.packages("quantmod")
library(quantmod)
library(ggplot2)

pbr <- getSymbols("PBR", src = "yahoo", from = "2013-01-01", to = "2020-01-01", auto.assign = FALSE)
```

```{r, echo=FALSE}

plot(pbr[,6], main = 'Petrobras prices')


```



It, seems ok, let's take a look at the returns


```{r, include=TRUE, message=FALSE, warning=FALSE}

pbr_ret = CalculateReturns(pbr[,6])

#Honey in the chupet

```

```{r, echo=FALSE}

plot(pbr_ret, main = 'Petrobras returns')


```



```{r, message=FALSE, include=TRUE}


# Compute the rolling 1 month estimate of annualized volatility
chart.RollingPerformance(R = pbr_ret["2000::2020"], width = 22,
     FUN = "sd.annualized", scale = 252, main = "One month rolling volatility")

```


```{r, echo=FALSE}


# Compute the rolling 3 months estimate of annualized volatility
chart.RollingPerformance(R = pbr_ret["2000::2020"], width = 66,
     FUN = 'sd.annualized', scale = 252, main = "Three months rolling volatility")


```


```{r, message=FALSE}



# Compute the mean daily return
m <- mean(data.frame(data=pbr_ret , coredata(pbr_ret))[,1], na.rm = TRUE)

# Define the series of prediction errors
e <- data.frame(data=pbr_ret , coredata(pbr_ret))[-1,1] - m

# Plot the absolute value of the prediction errors
par(mfrow = c(2,1),mar = c(3, 2, 2, 2))
plot(abs(e))


```

```{r, message=FALSE}
# Plot the acf of the absolute prediction errors
acf(abs(e))

```


```{r, message=FALSE}

#Our beloved package
library(rugarch)


# Specify a standard GARCH model with constant mean
garchspec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                         variance.model = list(model = "sGARCH"), 
                         distribution.model = "norm")

# Estimate the model
garchfit <- ugarchfit(data = pbr_ret[-1], spec = garchspec)

# Use the method sigma to retrieve the estimated volatilities 
garchvol <- sigma(garchfit)

# Plotting our model volatility
plot(garchvol)





```


```{r, include=TRUE, message=FALSE, warning=FALSE}




# Compute unconditional volatility
sqrt(uncvariance(garchfit))

# Print last 10 ones in garchvol
tail(garchvol, 10)

# Forecast volatility 5 days ahead and add 
garchforecast <- ugarchforecast(fitORspec = garchfit, 
                     n.ahead = 5)

# Extract the predicted volatilities and print them
print(sigma(garchforecast))





# Compute the annualized volatility
annualvol <- sqrt(252) * sigma(garchfit)

# Compute the 5% vol target weights  
vt_weights <- 0.05 / annualvol

# Compare the annualized volatility to the portfolio weights in a plot
plot(merge(annualvol, vt_weights), multi.panel = TRUE)


```




```{r}



# Plot the return series
plot(pbr_ret)

# Specify the garch model to be used
garchspec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                       variance.model = list(model = "sGARCH"),
                        distribution.model = 'sstd')

# Estimate the model
garchfit <- ugarchfit(data = pbr_ret[-1], spec = garchspec)

# Inspect the coefficients
coef(garchfit)










```


```{r, warning=FALSE}








# Compute the standardized returns
stdret <- residuals(garchfit, standardize = TRUE)

# Compute the standardized returns using fitted() and sigma()
stdret <- (pbr_ret - fitted(garchfit)) / sigma(garchfit)

# Load the package PerformanceAnalytics and make the histogram
library(PerformanceAnalytics)
chart.Histogram(stdret, methods = c("add.normal","add.density" ), 
                colorset = c("gray","red","blue"))







```












```{r}


# Specify the GJR GARCH model
garchspec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                 variance.model = list(model = 'gjrGARCH'),
                 distribution.model = 'sstd')

# Estimate the model and compute volatility
gjrgarchfit <- ugarchfit(data = pbr_ret[-1], spec = garchspec)
gjrgarchvol <- sigma(gjrgarchfit)

# Compare volatility
plotvol <- plot(abs(pbr_ret[-1]), col = "grey")
plotvol <- addSeries(gjrgarchvol, col = "red", on=1)
plotvol <- addSeries(sigma(garchfit), col = "blue", on=1)
plotvol





```







```{r}




# Specify AR(1)-GJR GARCH model
garchspec <- ugarchspec(mean.model = list(armaOrder = c(1,2) ),
                        variance.model = list(model = "gjrGARCH"),
                        distribution.model = "sstd")

# Estimate the model
garchfit <- ugarchfit(data=pbr_ret[-1],spec = garchspec, mean.model=c(1,0))

# Print the first two coefficients
coef(garchfit)[c(1:2)]





```







```{r}




```






```{r}




```






```{r}





```




