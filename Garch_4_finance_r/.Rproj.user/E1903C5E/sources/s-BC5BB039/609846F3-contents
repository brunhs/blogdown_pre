---
title: "Garching our way out"
subtitle: 'Univariate time series analysis with our beloved R'
slug: univariate-sherlock-series-analysis
author: "Bruno Schock"
date: "2020-01-12"
categories: []
tags: 
  - prediction
  - R
  - time series
output:
  html_document:
    toc: yes
    number_sections: yes
    theme: cosmo
    highlight: tango
---




# **Volatility, "Xeroque" and the unnecessary complexity**

## **Simple matter**
 
Hello everyone, it's your boy Brun here, like always i've been doing many courses around, many things going on now that I moved to a new city, with a new job, new perspectives, life is being pretty volatile, you know? Do you know something that's pretty volatile too? Stocks! Yeah boy, they move pretty fast and with a very non-gentile pattern, but fortunately the world gave us some time series analysis and here we are.

Of course we are going to work with some price returns, do you know something better than returns? They're pretty good talking about the recent past, they can help us being more rich (time is money works here?), well, since we already talked about some time series in previous posts, in a small piece of how to predict with some different models, we're going to talk about some volatility estimation, something that can concern us, right? Trying to imagine if some time series is going to behave more volatile in the next future is something pretty good for us, since we can protect ourselves of these movements, no more chatting, let's begin. 
 

```{r, include=TRUE, message=FALSE, warning=FALSE}
#Loading our packages
library(PerformanceAnalytics)




```



## **Get the data, 'bo1s' and 'g4ls'**

Yeah, this chunk is to get the data and plot it, you know we can't keep without it!


```{r, include=TRUE, message=FALSE, warning=FALSE}
#Loading our stocks
#install.packages("quantmod")
library(quantmod)
library(ggplot2)

pbr <- getSymbols("PBR", src = "yahoo", from = "2013-01-01", to = "2020-01-01", auto.assign = FALSE)
```

```{r, echo=FALSE}

plot(pbr[,6], main = 'Petrobras prices')


```



It, seems ok, let's take a look at the returns


```{r, include=TRUE, message=FALSE, warning=FALSE}

pbr_ret = CalculateReturns(pbr[,6])

#Honey in the chupet

```

```{r, echo=FALSE}

plot(pbr_ret, main = 'Petrobras returns')


```



```{r, message=FALSE, include=TRUE}


# Compute the rolling 1 month estimate of annualized volatility
chart.RollingPerformance(R = pbr_ret["2000::2020"], width = 22,
     FUN = "sd.annualized", scale = 252, main = "One month rolling volatility")

```


```{r, echo=FALSE}


# Compute the rolling 3 months estimate of annualized volatility
chart.RollingPerformance(R = pbr_ret["2000::2020"], width = 66,
     FUN = 'sd.annualized', scale = 252, main = "Three months rolling volatility")


```


```{r, message=FALSE}



# Compute the mean daily return
m <- mean(data.frame(data=pbr_ret , coredata(pbr_ret))[,1], na.rm = TRUE)

# Define the series of prediction errors
e <- data.frame(data=pbr_ret , coredata(pbr_ret))[-1,1] - m

# Plot the absolute value of the prediction errors
par(mfrow = c(2,1),mar = c(3, 2, 2, 2))
plot(abs(e))


```

```{r, message=FALSE}
# Plot the acf of the absolute prediction errors
acf(abs(e))

```


```{r, message=FALSE}





# Specify a standard GARCH model with constant mean
garchspec <- ugarchspec(mean.model = list(armaOrder = c(0,0)),
                         variance.model = list(model = "sGARCH"), 
                         distribution.model = "norm")

# Estimate the model
garchfit <- ugarchfit(data = sp500ret, spec = garchspec)

# Use the method sigma to retrieve the estimated volatilities 
garchvol <- sigma(garchfit)

# Plot the volatility for 2017
plot(garchvol["2017"])





```



## Do you even GARCH?


```{r, include=TRUE, message=FALSE, warning=FALSE}




#Honey in the chupet

```
